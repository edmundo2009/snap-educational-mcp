

## Actionable Implementation Plan for the Hybrid Orchestration Engine

Here is a step-by-step guide to evolving your `block_generator.py` into the "Master Chef" described in your project documentation.

#### **Step 1: Prerequisites - Setup Gemini API**

1.  **Install the Library**: Add the Google Generative AI library to your `requirements.txt` and install it.
    ```text
    # requirements.txt
    google-generativeai>=0.3.0
    ```
    Run `pip install -r requirements.txt`.

2.  **Configure API Key**: Set your Gemini API key as an environment variable. Your code already uses `python-dotenv`, so add it to your `.env` file.
    ```text
    # .env file
    GEMINI_API_KEY="YOUR_API_KEY_HERE"
    ```

#### **Step 2: Redesign `SnapBlockGenerator` in `block_generator.py`**

Refactor the `SnapBlockGenerator` class to implement the new hybrid logic.

```python
# mcp_server/tools/block_generator.py

import os
import json
import google.generativeai as genai
from ..parsers.intent_parser import ParsedIntent
# Import your new validator function (see Step 3)
# from ..parsers.validators import validate_snap_json

# Configure the Gemini client
genai.configure(api_key=os.environ["GEMINI_API_KEY"])

class SnapBlockGenerator:
    def __init__(self, knowledge_path: str, patterns_path: str):
        self.knowledge_path = knowledge_path
        self.patterns_path = patterns_path
        self.blocks_db = self._load_json(knowledge_path)
        self.patterns_db = self._load_json(patterns_path)
        self.allowed_opcodes = self._get_all_opcodes()
        self.model = genai.GenerativeModel('gemini-1.5-flash') # Or another suitable model

    def _load_json(self, path):
        with open(path, 'r') as f:
            return json.load(f)

    def _get_all_opcodes(self) -> set:
        opcodes = set()
        for category in self.blocks_db['blocks'].values():
            opcodes.update(category.keys())
        return opcodes

    def generate_snap_json(self, intent: ParsedIntent, user_description: str) -> dict:
        """
        Orchestrator method to generate Snap! JSON.
        Tries the rule-based path first, then falls back to the generative path.
        """
        # --- Phase 1: Fast Path (Rule-Based) ---
        pattern = self._find_matching_pattern(intent.action)
        if pattern:
            print("✅ Found matching pattern. Using rule-based engine.")
            block_sequence = self._create_from_pattern(pattern, intent)
            generated_json = self.format_for_snap(block_sequence, "Sprite") # Assuming 'Sprite' for now
        else:
            # --- Phase 2: Powerful Path (Generative) ---
            print("🤔 No simple pattern found. Escalating to generative engine.")
            generated_json = self._call_generative_engine(user_description)

        # --- Phase 3: Universal Validation (CRITICAL) ---
        # is_valid, error = validate_snap_json(generated_json, self.allowed_opcodes)
        # if not is_valid:
        #     raise ValueError(f"Generated JSON is invalid or unsafe: {error}")

        return generated_json

    def _find_matching_pattern(self, action: str):
        # Your existing logic to find a pattern in patterns.json
        pass

    def _create_from_pattern(self, pattern: dict, intent: ParsedIntent):
        # Your existing logic to build a BlockSequence from a pattern
        pass

    def _build_gemini_prompt(self, user_request: str) -> str:
        prompt = f"""
You are an expert Snap! visual programming assistant. Your sole task is to convert a user's request into a single, valid JSON object that conforms to the specified format for creating Snap! blocks.

**RULES:**
1. You MUST respond with only a single, raw JSON object. Do not include markdown, explanations, or any other conversational text in your output.
2. Analyze the user's request to determine the correct sequence of blocks, their inputs, and any necessary event triggers (hat blocks).
3. Use only the opcodes provided in the "Available Opcodes" list. Do not invent new ones.
4. The first block in a script should have its `is_hat_block` property set to `true`.
5. Connect blocks sequentially using the `next` property, referencing the `block_id` of the subsequent block. The last block's `next` should be `null`.

**Available Opcodes:**
{json.dumps(list(self.allowed_opcodes), indent=2)}

**JSON OUTPUT STRUCTURE:**
{{
  "command": "create_blocks",
  "payload": {{
    "target_sprite": "Sprite",
    "scripts": [{{
      "script_id": "script_001",
      "position": {{"x": 50, "y": 50}},
      "blocks": [
        {{
          "block_id": "block_001",
          "opcode": "...",
          "category": "...",
          "inputs": {{ ... }},
          "is_hat_block": true,
          "next": "block_002"
        }},
        {{
          "block_id": "block_002",
          "opcode": "...",
          "category": "...",
          "inputs": {{ ... }},
          "is_hat_block": false,
          "next": null
        }}
      ]
    }}]
  }}
}}

---
**USER REQUEST:**
"{user_request}"
---

**YOUR JSON RESPONSE:**
"""
        return prompt

    def _call_generative_engine(self, user_description: str) -> dict:
        prompt = self._build_gemini_prompt(user_description)
        try:
            response = self.model.generate_content(prompt)
            # Clean up the response to extract only the JSON part
            cleaned_response = response.text.strip().replace("```json", "").replace("```", "").strip()
            return json.loads(cleaned_response)
        except Exception as e:
            print(f"❌ Generative engine failed: {e}")
            # Return a fallback error structure
            return {
                "command": "create_blocks",
                "payload": { "error": "Failed to generate blocks.", "details": str(e) }
            }
            
    def format_for_snap(self, block_sequence, target_sprite):
        # Your existing formatting logic
        pass

```

#### **Step 3: Implement the Validation Layer in `validators.py`**

Create the `validate_snap_json` function and the corresponding Pydantic schemas. This function is crucial for security and stability.

```python
# mcp_server/parsers/validators.py
from pydantic import BaseModel, Field, ValidationError
from typing import List, Dict, Any, Optional, Tuple

# ... (define the Pydantic schemas as shown in the summary above) ...
class BlockSchema(...):
class ScriptSchema(...):
class PayloadSchema(...):
class SnapJSONSchema(...):


def validate_snap_json(generated_json: dict, allowed_opcodes: set) -> Tuple[bool, Optional[str]]:
    """
    Validates the structure and content of the generated Snap! JSON.
    Returns (is_valid, error_message).
    """
    # 1. Structural Integrity Check
    try:
        SnapJSONSchema.model_validate(generated_json)
    except ValidationError as e:
        return False, f"JSON structure validation failed: {e}"

    all_block_ids = set()
    next_block_references = set()

    for script in generated_json['payload']['scripts']:
        for block in script['blocks']:
            all_block_ids.add(block['block_id'])
            if block['next']:
                next_block_references.add(block['next'])

            # 2. Opcode Allowlist Check
            if block['opcode'] not in allowed_opcodes:
                return False, f"Disallowed opcode used: {block['opcode']}"

    # 3. Connectivity Check
    if not next_block_references.issubset(all_block_ids):
        unresolved_refs = next_block_references - all_block_ids
        return False, f"Invalid 'next' reference. Blocks not found: {unresolved_refs}"

    return True, None
```

#### **Step 4: Update the `generate_snap_blocks` Tool in `main.py`**

Modify the tool to call the new orchestrator method and handle potential validation errors.

```python
# mcp_server/main.py

# ... (imports)

@mcp.tool()
async def generate_snap_blocks(
	description: str,
	# ... other args
) -> Dict[str, Any]:
    # ...
    try:
        # 1. Parse intent (no changes here)
        intents = parser.parse(description)
        if not intents:
            # ...

        # For now, we assume a single intent for simplicity.
        # The prompt works best with the original, full description.
        main_intent = intents[0]

        # 2. Call the new generation orchestrator
        snap_spec = generator.generate_snap_json(main_intent, description)

        # (The validation is now handled inside the generator)

        # 3. Check for generation errors before proceeding
        if snap_spec.get("payload", {}).get("error"):
            return {"success": False, "error": snap_spec["payload"]["error"]}

		# 4. Send to browser via communicator (no changes here)
        # ...

    except ValueError as e: # Catches validation errors
        return {"success": False, "error": f"Block generation failed: {e}"}
    except Exception as e:
        return {"success": False, "error": str(e), "error_type": "generation_failed"}
```